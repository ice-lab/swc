use crate::lazy_static;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use swc_common::DUMMY_SP;
use swc_ecmascript::ast::{
    BindingIdent, Bool, Decl, Expr, Ident, ImportNamedSpecifier, ImportSpecifier,
    ImportStarAsSpecifier, KeyValueProp, Lit, ModuleDecl, ModuleItem, ObjectLit, Pat, Prop,
    PropName, PropOrSpread, Stmt, VarDecl, VarDeclKind, VarDeclarator,
};

use swc_ecmascript::visit::Fold;

use swc_atoms::JsWord;

#[derive(Debug, Deserialize, Default, Clone)]
pub struct KeepPlatformPatcher {
    pub platform: String,
}

/// Configuration related to source map generated by swc.
#[derive(Clone, Serialize, Deserialize, Debug)]
#[serde(untagged)]
pub enum KeepPlatformConfig {
    Bool(bool),
    KeepPlatform(String),
}

impl Default for KeepPlatformConfig {
    fn default() -> Self {
        KeepPlatformConfig::Bool(false)
    }
}

pub fn keep_platform(options: KeepPlatformConfig) -> impl Fold {
    let platform: String = match options {
        KeepPlatformConfig::KeepPlatform(platform) => platform,
        _ => "".to_string(),
    };
    KeepPlatformPatcher { platform: platform }
}

// platform maps
lazy_static! {
    static ref PLATFORM_MAP: HashMap<String, Vec<String>> = HashMap::from([
        ("web".to_string(), vec!["isWeb".to_string()]),
        ("node".to_string(), vec!["isNode".to_string()]),
        ("weex".to_string(), vec!["isWeex".to_string()]),
        (
            "kraken".to_string(),
            vec!["isKraken".to_string(), "isWeb".to_string()]
        ),
        (
            "wechat-miniprogram".to_string(),
            vec![
                "isWeChatMiniProgram".to_string(),
                "isWeChatMiniprogram".to_string()
            ]
        ),
        ("miniapp".to_string(), vec!["isMiniApp".to_string()]),
        (
            "bytedance-microapp".to_string(),
            vec!["isByteDanceMicroApp".to_string()]
        ),
        (
            "kuaishou-miniprogram".to_string(),
            vec!["isKuaiShouMiniProgram".to_string()]
        ),
        (
            "baidu-smartprogram".to_string(),
            vec!["isBaiduSmartProgram".to_string()]
        ),
    ]);
}

impl Fold for KeepPlatformPatcher {
    fn fold_module_items(&mut self, items: Vec<ModuleItem>) -> Vec<ModuleItem> {
        // Get platform flag, such as ["isWeb"]
        let platform_flags: Vec<String> = match PLATFORM_MAP.get(&self.platform.to_string()) {
            Some(flags) => flags.to_vec(),
            None => vec![],
        };
        // Collect top-level expression
        let mut new_module_items: Vec<ModuleItem> = vec![];
        // Save isWeb/isWeex into env_variables
        let mut env_variables: Vec<&Ident> = vec![];

        // Decls witch need be inserted into module items
        let mut decls: Vec<VarDeclarator> = vec![];

        for module_item in items.iter() {
            match module_item {
                ModuleItem::ModuleDecl(ModuleDecl::Import(import_decl)) => {
                    if check_source(&import_decl.src.value) {
                        for specifier in import_decl.specifiers.iter() {
                            match specifier {
                                ImportSpecifier::Named(named) => {
                                    let ImportNamedSpecifier {
                                        local,
                                        span: _,
                                        imported: _,
                                        is_type_only: _,
                                    } = named;
                                    env_variables.push(local);
                                }
                                ImportSpecifier::Namespace(namespace) => {
                                    let ImportStarAsSpecifier { local, span: _ } = namespace;
                                    decls.push(create_var_decl(
                                        local.clone(),
                                        Option::Some(Box::new(Expr::Object(ObjectLit {
                                            span: DUMMY_SP,
                                            // Create object by platform_flags, such as { isWeb: true }
                                            props: platform_flags
                                                .iter()
                                                .map(|platform| {
                                                    PropOrSpread::Prop(Box::new(Prop::KeyValue(
                                                        KeyValueProp {
                                                            key: PropName::Ident(
                                                                create_jsword_ident(platform),
                                                            ),
                                                            value: Box::new(create_bool_expr(true)),
                                                        },
                                                    )))
                                                })
                                                .collect(),
                                        }))),
                                    ))
                                }
                                _ => {}
                            }
                        }
                    } else {
                        new_module_items.push(ModuleItem::ModuleDecl(ModuleDecl::Import(
                            import_decl.clone(),
                        )))
                    }
                }
                _ => new_module_items.push(module_item.clone()),
            }
        }

        // If it exist env variables, we need insert declare expression
        if env_variables.len() > 0 {
            for env_variable in env_variables {
                decls.push(create_var_decl(
                    env_variable.clone(),
                    Option::Some(Box::new(create_bool_expr(
                        platform_flags.contains(&env_variable.sym.to_string()),
                    ))),
                ));
            }
        }

        insert_decls_into_module_items(decls, &mut new_module_items);

        return new_module_items;
    }
}

// Check import source whether @uni/env or universal-env
fn check_source(source: &str) -> bool {
    source == "universal-env" || source == "@uni/env"
}

// Insert variable declarator into module items, exp: var isWeb = true;
fn insert_decls_into_module_items(decls: Vec<VarDeclarator>, module_items: &mut Vec<ModuleItem>) {
    if decls.len() > 0 {
        module_items.insert(
            0,
            ModuleItem::Stmt(Stmt::Decl(Decl::Var(VarDecl {
                span: DUMMY_SP,
                kind: VarDeclKind::Var,
                declare: false,
                decls: decls,
            }))),
        )
    }
}

// Create Ident by jsword
fn create_jsword_ident(value: &str) -> Ident {
    Ident {
        span: DUMMY_SP,
        sym: JsWord::from(value),
        optional: Default::default(),
    }
}

// Create variable declaration
fn create_var_decl(id: Ident, init: Option<Box<Expr>>) -> VarDeclarator {
    let decl_name = Pat::Ident(BindingIdent {
        id: id,
        type_ann: Default::default(),
    });

    VarDeclarator {
        name: decl_name,
        init,
        span: DUMMY_SP,
        definite: false,
    }
}

// Create bool expr, such as: true
fn create_bool_expr(value: bool) -> Expr {
    Expr::Lit(Lit::Bool(Bool {
        value: value,
        span: Default::default(),
    }))
}
